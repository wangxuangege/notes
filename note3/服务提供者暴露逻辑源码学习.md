DUBBO服务提供者暴露逻辑源码学习
=================

&nbsp;&nbsp;&nbsp;&nbsp;一般dubbo服务采用的是xml式的发布方式，在dubbo的DubboNamespaceHandler中定义了Spring Framework 的扩展标签，即<dubbo:service>等，dubbo通过DubboBeanDefinitionParser将不同的标签分别解析到不同的bean中。
- &nbsp;1.application -> ApplicationConfig
- &nbsp;2.module -> ModuleConfig
- &nbsp;3.registry -> RegistryConfig
- &nbsp;4.monitor -> MonitorConfig
- &nbsp;5.provider -> ProviderConfig
- &nbsp;6.consumer -> ConsumerConfig
- &nbsp;7.protocol -> ProtocolConfig
- &nbsp;8.service -> ServiceBean
- &nbsp;9.reference -> ReferenceBean

&nbsp;&nbsp;&nbsp;&nbsp;DUBBO服务提供如<dubbo:service interface="com.xxx.xxx.xxxService" ref="xxxService" timeout="5000"/>，会被解析成ServiceBean，服务发布入口从ServiceBean的afterPropertiesSet/onApplicationEvent，从ServiceConfig的export开始发布。

# ServiceConfig 类

&nbsp;&nbsp;&nbsp;&nbsp;执行顺序：export -> doExport -> doExportUrls -> doExportUrlsFor1Protocol。

&nbsp;&nbsp;&nbsp;&nbsp;export判断是否延迟发布，如果延迟发布会新建个Daemon线程然后调用doExport(), 否则直接调用doExport()；
~~~java
private void doExportUrls() {
     List<URL> registryURLs = loadRegistries(true);
    for (ProtocolConfig protocolConfig : protocols) {
        doExportUrlsFor1Protocol(protocolConfig, registryURLs);
    }
}
~~~

&nbsp;&nbsp;&nbsp;&nbsp;doExportUrls执行loadRegistries()遍历注册中心，根据注册中心、Dubbo版本、Pid等生成要发布的URL(URL示例： zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=ordercenter_serviceImpl&dubbo=2.8.4&pid=15836&registry=zookeeper&timestamp=1484018365125)，然后遍历服务协议，为每个协议单独调用doExportUrlsFor1Protocol。

![服务暴露过程](static/服务暴露过程.png)

&nbsp;&nbsp;&nbsp;&nbsp;doExportUrlsFor1Protocol中会填充要发布的methods，然后为每个要发布的服务创建一个invoker，其中ProxyFactory有JdkProxyFactory、JavassistProxyFactory，DUBBO默认使用JavassistProxyFactory（性能较高），默认的协议是DubboProtocol。
~~~java
// 填充要发布的methods
String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();
~~~
~~~java
Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));
DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
Exporter<?> exporter = protocol.export(wrapperInvoker);
~~~

&nbsp;&nbsp;&nbsp;&nbsp;JavassistProxyFactory类实现如下：
~~~java
public class JavassistProxyFactory extends AbstractProxyFactory {

    public <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {
        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));
    }

    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {
        // invoker里面的服务调用是依赖wrapper执行的
        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);
        return new AbstractProxyInvoker<T>(proxy, type, url) {
            @Override
            protected Object doInvoke(T proxy, String methodName,
                                      Class<?>[] parameterTypes,
                                      Object[] arguments) throws Throwable {
                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
            }
        };
    }
}
~~~

&nbsp;&nbsp;&nbsp;最后，调用DubboProtocol的export，执行顺序：export -> openServer ->createServer。createServer通过Exchangers.bind，创建ExchangeServer。
~~~java
public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
    URL url = invoker.getUrl();

    // export service.
    String key = serviceKey(url);
    DubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);
    exporterMap.put(key, exporter);

    //export an stub service for dispatching event
    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);
    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, false);
    if (isStubSupportEvent && !isCallbackservice) {
        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);
        if (stubServiceMethods == null || stubServiceMethods.length() == 0) {
            if (logger.isWarnEnabled()) {
                logger.warn(new IllegalStateException("consumer [" + url.getParameter(Constants.INTERFACE_KEY) +
                    "], has set stubproxy support event ,but no stub methods founded."));
            }
        } else {
            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);
        }
    }

    openServer(url);
    optimizeSerialization(url);
    return exporter;
}
~~~

&nbsp;&nbsp;&nbsp;&nbsp;总结整个服务发布流程如下：

![服务发布](static/服务发布.png)

![服务发布时序](static/服务发布时序.jpg)